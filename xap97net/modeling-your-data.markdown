---
layout: post
title:  Modeling your Data
categories: XAP97NET
parent: programmers-guide.html
weight: 300
---

{%wbr%}

{%section%}
{%column width=10% %}
![data-access.jpg](/attachment_files/subject/data-access.png)
{%endcolumn%}
{%column width=90% %}
Modeling your objects that are used to interact with the space.
{%endcolumn%}
{%endsection%}

<hr/>

- [Space Object ID](./poco-object-id.html){%wbr%}
When a new object is inserted into the space, it embeds a unique ID - called the UID. The UID can be generated explicitly by the client using a unique value generated by the application business logic or using a sequencer running within the space.

- [Metadata](./poco-metadata.html){%wbr%}
The XAP API supports class decorations with POCOs. These can be specified via annotations on the space class source itself or external xml file. You can define common behavior for all class instances, and specific behavior for class fields.

- [XML Metadata](./poco-gs.xml-metadata.html){%wbr%}
Defining metadata with a configuration file  (gs.xml).

- [Storage Types](./poco-storage-type.html){%wbr%}
To reduce the memory footprint of the objects stored in space, different storage types can be defined for individual properties of a space class. Object properties can be assigned a storage type decoration which determines how it is serialized and stored in the space.

- [Type Discovery](./poco-type-discovery.html){%wbr%}
Controlling data type discovery.

- [Routing Property](./routing-in-partitioned-spaces.html){%wbr%}
A partitioned space provides the ability to perform space operations against multiple spaces from a single proxy transparently. The primary goal of the partitioned space is to provide unlimited In-Memory space storage size and group objects into the same partition to speed up performance. The initial intention is to write data into the partitioned space, and route query operations based on the template data. In order to accomplish that, a routing property can be defined on the entry type.
<hr/>



